module PrimeCWI;

interface ISieve {
	Bool sieve(Int n);
}

interface IGen{
	Unit run_par();
}

class Generator (Int limit, Int elem) implements IGen{

	Int size = 0;
    Int last =0;
    Int i =0 ;
    Int n = 3;
    
    Map <Int,Bool> current_Map = EmptyMap;
    Map <Int, ISieve> processors_Map = EmptyMap;
    
   	List<Int> primes = Cons(2,Nil);
    // Init-block:
	// Establish array size for each process.
	// We will only use even number => double the search space
    {
   	size = limit/elem;
    limit = limit*2;

    //Send info to all processes:
	// x=starting prime (3)
	// size = their array's size
	// p = their process id
    Int p = elem;    
    while(p>1){
    	p = p-1;
    	ISieve gen = new Sieve(n, size, p);
    	processors_Map = insert(processors_Map,Pair(p, gen));
    	}
    last = n + size*2; 
    i=last-2;	
    
    //construct the Map of numbers for the first processor.		
    while (i>=n){
    	current_Map = insert(current_Map,Pair(i, true));
    	i = i - 2;
    	}
    }
    
    Unit print() {
    	println(this.primes);
    	println(this.current_Map);
    }


//method for sieving using the current prime number. To be run in parallel by all processors.
	Unit run_par(){
		while ((current_Map!=EmptyMap)&&(n*n<limit)){
			println(n);	
			Int k=1;	
				
			if(lookupUnsafe(current_Map,n)==True){
				while(k<elem){
					Int finalK = k;
					ISieve worker = lookupUnsafe(processors_Map, finalK); 					
					Fut<Bool> f = worker!sieve(n);
					k=k+1;
				}
			
				primes = Cons(n,primes);
				current_Map = removeKey(current_Map, n);
			
				Int first = n*n;
				Int j= first;
				while (j<last){
					current_Map=put(current_Map,j, False);
					j = j+(2*n);
				}
			
			}
			n=n+2;
		}
	}
	
}

class Sieve(Int p, Int size, Int pe) implements ISieve {
	
	Map <Int,Bool> current_Map = EmptyMap;	
    Int i=0;
    Int last=0;
    
    //Init block. Uses p, size and pe to determine its Map of numbers.
    {
    this.i = p + pe*size*2;
    this.last = this.i + size*2 - 2; 
    
    while (this.i<= this.last){
    	current_Map = insert(this.current_Map, Pair(this.last, True));
    	this.last = this.last - 2;
    	}
    this.last = this.i + size*2;	
    //i = p + pe*size*2;
    }	

	Bool sieve(Int the_prime){
		println(the_prime);
		Int n = the_prime;
		Int first = n*n;
		Int j;
		if(this.i< first)
			j=first;
		else{
			if (first % n == 0){
				j=first;
			}
			else{ 
				j= (this.i/n) + (n* (this.i % n));
			}
		}
		
		while (j<=this.last){
			current_Map=put(current_Map,j, False);
			j = j+(2*n);
		}
		
		return True;	
		
	}    
}

{ // Main block:
	Generator g=new Generator(100,4);
	g.run_par();
	g.print();
}