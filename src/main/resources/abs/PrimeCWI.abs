module PrimeCWI;

interface ISieve {
	Bool sieve(Int n);
}

interface IGen{
	Unit run_par();
}

class Generator (Int limit, Int elem) implements IGen{

	Int size = 0;
    Int last =0;
    Int i =0 ;
    Int n = 3;
    
    Map <Int,Bool> current_Map = EmptyMap;
    Map <Int, ISieve> processors_Map = EmptyMap;
    
   	List<Int> primes = Cons(2,Nil);
    // Init-block:
	// Establish array size for each process.
	// We will only use even number => double the search space
    {
   	size = limit/elem;
    limit = limit*2;

    //Send info to all processes:
	// x=starting prime (3)
	// size = their array's size
	// p = their process id
    Int p = elem;    
    while(p>1){
    	p = p-1;
    	ISieve gen = new Sieve(n, size, p);
    	processors_Map = insert(processors_Map,Pair(p, gen));
    	}
    last = n + size*2; 
    i=last-2;	
    
    //construct the Map of numbers for the first processor.		
    while (i>=n){
    	current_Map = insert(current_Map,Pair(i, true));
    	i = i - 2;
    	}
    }
    
    Unit print() {
    	println(this.primes);
    }


//method for sieving using the current prime number. To be run in parallel by all processors.
	Unit run_par(){
		while ((current_Map!=EmptyMap)&&(n*n<limit)){
			
			Int k=1;	
				
			while(k<elem){
				Int finalK = k;					
				Fut<Bool> f = lookupUnsafe(processors_Map, finalK)!sieve(n);
				k=k+1;
			}
			
			if(lookupUnsafe(current_Map,n)==True){
				primes = Cons(n,primes);
				current_Map = removeKey(current_Map, n);
			
				Int first = n*n;
				Int j= first;
				while (j<last){
					current_Map=put(current_Map,j, False);
					j = j+(2*n);
				}
			
			}
			n=n+2;
		}
	}
}

class Sieve(Int p, Int size, Int pe) implements ISieve {
	
	Map <Int,Bool> current_Map = EmptyMap;	
    Int i=0;
    Int last=0;
    
    //Init block. Uses p, size and pe to determine its Map of numbers.
    {
    i = p + pe*size*2;
    last = i + size*2 - 2; 
    
    while (i<= last){
    	current_Map = insert(current_Map, Pair(last, True));
    	last = last - 2;
    	}
    last = i + size*2;	
    //i = p + pe*size*2;
    }	

	Bool sieve(Int the_prime){
	
		Int n = the_prime;
		Int first = n*n;
		Int j;
		
		if(i< first)
			j=first;
		else{
			if (first % n == 0){
				j=first;
			}
			else{ 
				j= (i/n) + (n* (i % n));
			}
		}
		
		while (j<=last){
			current_Map=put(current_Map,j, False);
			j = j+(2*n);
		}
		
		
		return True;	
		
	}    
}

{ // Main block:
	Generator g=new Generator(50000,1);
	Fut<Unit> f = g!run_par();
	await f?;
	g.print();
}